package sequencer

import (
	"bytes"
	"context"

	"github.com/sig-0/go-ibft/message"
	"github.com/sig-0/go-ibft/message/store"
)

func (s *Sequencer) sendMsgCommit() {
	msg := &message.MsgCommit{
		Info: &message.MsgInfo{
			Sequence: s.state.sequence,
			Round:    s.state.round,
			Sender:   s.validator.Address(),
		},
		BlockHash:  s.state.acceptedBlockHash(),
		CommitSeal: s.validator.Sign(s.state.acceptedBlockHash()),
	}

	s.transport.MulticastCommit(message.SignMsg(msg, s.validator))
}

func (s *Sequencer) awaitCommitQuorum(ctx context.Context) ([]*message.MsgCommit, error) {
	sub, cancelSub := s.feed.SubscribeCommit(s.state.sequence, s.state.round, false)
	defer cancelSub()

	cache := store.NewMsgCache(s.isValidMsgCommit)

	for {
		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		case notification := <-sub:
			cache.Add(notification.Unwrap()...)

			commits := cache.Get()
			if len(commits) == 0 || !s.validatorSet.HasQuorum(message.WrapMessages(commits...)) {
				continue
			}

			return commits, nil
		}
	}
}

func (s *Sequencer) isValidMsgCommit(msg *message.MsgCommit) bool {
	// sender must be part of the validator set
	if !s.validatorSet.IsValidator(msg.Info.Sender, msg.Info.Sequence) {
		return false
	}

	// block hash and accepted block hash must match
	if !bytes.Equal(msg.BlockHash, s.state.acceptedBlockHash()) {
		return false
	}

	// commit seal was generated by signing block hash
	if err := s.sig.Verify(msg.Info.Sender, msg.BlockHash, msg.CommitSeal); err != nil {
		return false
	}

	return true
}
