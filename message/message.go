package message

import (
	"google.golang.org/protobuf/proto"
)

// Message is an opaque wrapper for the IBFT consensus messages. See message.proto for concrete type definitions
type Message interface {
	GetInfo() *MsgInfo
}

// Signer is used to generate unique signatures based on some digest
type Signer interface {
	// Sign returns the signature generated from digest
	Sign(digest []byte) []byte
}

// SignatureVerifier validates Signer signatures
type SignatureVerifier interface {
	// Verify checks if signature was generated by signer for a particular digest
	Verify(signer, digest, signature []byte) error
}

// WrapMessages wraps concrete message types into Message type
func WrapMessages[M Message](messages ...M) []Message {
	wrapped := make([]Message, 0, len(messages))
	for _, msg := range messages {
		wrapped = append(wrapped, Message(msg))
	}

	return wrapped
}

func (x *MsgProposal) Payload() []byte {
	xx := &MsgProposal{
		Info: &MsgInfo{
			Sequence: x.Info.Sequence,
			Round:    x.Info.Round,
			Sender:   x.Info.Sender,
		},
		ProposedBlock:          x.ProposedBlock,
		BlockHash:              x.BlockHash,
		RoundChangeCertificate: x.RoundChangeCertificate,
	}

	payload, _ := proto.Marshal(xx) //nolint:errcheck //proto
	return payload
}

func (x *MsgPrepare) Payload() []byte {
	xx := &MsgPrepare{
		Info: &MsgInfo{
			Sequence: x.Info.Sequence,
			Round:    x.Info.Round,
			Sender:   x.Info.Sender,
		},
		BlockHash: x.BlockHash,
	}

	payload, _ := proto.Marshal(xx) //nolint:errcheck //proto
	return payload
}

func (x *MsgCommit) Payload() []byte {
	xx := &MsgCommit{
		Info: &MsgInfo{
			Sequence: x.Info.Sequence,
			Round:    x.Info.Round,
			Sender:   x.Info.Sender,
		},
		BlockHash:  x.BlockHash,
		CommitSeal: x.CommitSeal,
	}

	payload, _ := proto.Marshal(xx) //nolint:errcheck //proto
	return payload
}

func (x *MsgRoundChange) Payload() []byte {
	xx := &MsgRoundChange{
		Info: &MsgInfo{
			Sequence: x.Info.Sequence,
			Round:    x.Info.Round,
			Sender:   x.Info.Sender,
		},
		LatestPreparedProposedBlock: x.LatestPreparedProposedBlock,
		LatestPreparedCertificate:   x.LatestPreparedCertificate,
	}

	payload, _ := proto.Marshal(xx) //nolint:errcheck //proto
	return payload
}

func (x *ProposedBlock) Bytes() []byte {
	bz, _ := proto.Marshal(x) //nolint:errcheck //proto
	return bz
}

func (rcc *RoundChangeCertificate) HighestRoundBlock() ([]byte, uint64) {
	roundsAndPreparedBlocks := make(map[uint64][]byte)
	for _, msg := range rcc.Messages {
		pb := msg.LatestPreparedProposedBlock
		pc := msg.LatestPreparedCertificate

		if pb == nil || pc == nil {
			continue
		}

		roundsAndPreparedBlocks[pc.ProposalMessage.Info.Round] = pb.Block
	}

	if len(roundsAndPreparedBlocks) == 0 {
		return nil, 0
	}

	var (
		highestRound      uint64
		highestRoundBlock []byte
	)

	for round, block := range roundsAndPreparedBlocks {
		if round >= highestRound {
			highestRound = round
			highestRoundBlock = block
		}
	}

	return highestRoundBlock, highestRound
}

func (rcc *RoundChangeCertificate) HighestRoundBlockHash() ([]byte, uint64) {
	roundsAndPreparedBlockHashes := make(map[uint64][]byte)
	for _, msg := range rcc.Messages {
		pc := msg.LatestPreparedCertificate
		if pc == nil {
			continue
		}

		roundsAndPreparedBlockHashes[pc.ProposalMessage.Info.Round] = pc.ProposalMessage.BlockHash
	}

	if len(roundsAndPreparedBlockHashes) == 0 {
		return nil, 0
	}

	var (
		highestRound          uint64
		highestRoundBlockHash []byte
	)

	for round, proposalHash := range roundsAndPreparedBlockHashes {
		if round >= highestRound {
			highestRound = round
			highestRoundBlockHash = proposalHash
		}
	}

	return highestRoundBlockHash, highestRound
}
